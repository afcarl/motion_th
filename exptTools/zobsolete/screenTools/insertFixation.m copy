function img = insertFixation(display,img,fixParams)%% img = insertFixation(display,img,fixParams)%% AUTHOR: Boynton% DATE:   February, 1998.% PURPOSE: %    Creates a fixation point using the default display%    colors of 'black' and 'white' (reserved colors).% % ARGUMENTS:% % display:      display data structure% img:          the stimulus.image % % fixParams.size:      Fixation size.  %               Default is 0.5 degrees visual angle% fixParams.colors:    Fixation color.  %               Default is reserved hi and lo colors% fixParams.Position:  Fixation position.  %               Default is center of image. % fixParams.Image:     A fixation image (default is a black/white square)%               This image should have the same size as img.%               Values equal to -1 will be set to the lo reserved%               color and values equal to -2 will be set to the%               hi reserved color.%               %               Deviations are specified in terms of visual degrees.% % MODIFICATIONS:%   02.18.98:  BW added fixPosition, comments, variable name changes%   04.16.98:  BW, added fixImage input.% if isfield(fixParams,'image')  img = insertCustomFixation(display,img,fixParams);  return;endif ~isfield(fixParams,'size') fixSize = 0.5; else fixSize = fixParams.size; end% Measure image size and compute center% nRow=size(img,1);nCol=size(img,2);fixCenter = round([size(img,1),size(img,2)]/2);numImages = size(img,3);if ~isfield(fixParams,'colors')  hi = display.reservedColor(findName(display.reservedColor,'white')).fbVal;  lo = display.reservedColor(findName(display.reservedColor,'black')).fbVal;else  hi = fixParams.colors(2);  lo = fixParams.colors(1);end% Create the fixation image% % Measure fixation size so center of fixation can be in the% center of the image% disp('Using default fixation square')  s = floor(angle2pix(display,fixSize));margin =max(floor(angle2pix(display,fixSize/4)),1);[x,y]=meshgrid([1:s],[1:s]);fixImage = hi*ones(size(x));fixImage([margin+1:size(x,1)-margin],[margin+1:size(x,2)-margin])= ...    lo*ones(size(x)-margin*2);% Find the indices corresponding to the fixation location in the% image. % id =(1:prod(size(fixImage)))';% If the fixation position is not sent in, place it in the middle% of the image.  Do this by subtracting off one-half the box size% from the fixCenter position.if ~isfield(fixParams,'position'),  fixPosition = [0 0];else fixPosition = fixParams.position; end  % If the fixation position was sent in, then it was passed in as% an angle above or below the center of the image.  So, we will% compute the image center (as above) and add in the displacement.% The y-axis seems (to me, BW) to have strange orientation,% running from down to up.  The x-axis runs from left to right,% as I expected.% fixOffset = ...    [-angle2pix(display,fixPosition(1)), ...	angle2pix(display,fixPosition(2))];% Specificy the location (in pixels) of the bottom of the fixation.% fixCenter = fixCenter + fixOffset;fixBottom = [floor(fixCenter(2)-s/2)-1, ceil(fixCenter(1)-s/2)];% insert the fixation point into 'img' at the proper index locations.% for ii=1:numImages  img( nRow*(x(id)+fixBottom(1)) +   y(id)+fixBottom(2) + ...      (ii-1)*nRow*nCol) = fixImage(id); end% colormap(double(stimulus.cmap(:,:,1))/256); image(img)return;% Debugging stuff%               % img = stimulus.image;% fixSize = params.fix.size;% fixColors = params.fix.colors;% fixPosition = params.fix.position;% fixImage = -1*ones(20,20);% for ii=1:20%  fixImage(ii,ii) = hi;% endfoo = insertFixation(display,stimulus.image,...    fixSize,fixColors,fixPosition,fixImage);colormap(double(stimulus.cmap(:,:,1))/256); image(img)imshow(foo)