/*	bitmap = DrawText2Bitmap(textString, textRect, textSize, fontName, justification)			textString = matlab string (row vector of chars)		textRect = [top left right bottom]		textSize = font size in points (e.g., 12)		fontName = matlab string (try 'geneva', 'courier', 'new york', monaco', etc.		justification = -1 for right, 0 for left, 1 for center*/#include <Strings.h>	// c2pstr() and p2cstr()#include <stdlib.h>#include <stdio.h>#include <string.h>#include "mex.h"#include <Quickdraw.h>#include <Fonts.h>#include <QDOffscreen.h>#include <TextEdit.h>static void DrawText2Bitmap(const unsigned char *s, int pixelSize, unsigned long **bitmap, 				Rect *box, int size, const char *fontName, int justify);static void DrawText2Bitmap(const unsigned char *s, int pixelSize, unsigned long **bitmap, 				Rect *box, int size, const char *fontName, int justify)// some code lifted from Pelli's 'StringBounds' in 'StringBounds.c'// textJustify: 0 = left, 1 = center, -1 = right{	GWorldPtr gworld=NULL;	GWorldPtr old;	GDHandle oldDevice;//	FontInfo f;    Rect r, bounds;    long inkArea, rowBytes;	int error, rows, cols, i, j;	short fnum;	char string[40];	PixMap **pmHnd;	unsigned char *pixPtr;	GetGWorld(&old,&oldDevice);	// create a new GWorld	error = NewGWorld(&gworld, pixelSize, box, NULL, NULL, keepLocal|useTempMem);	if(error) error = NewGWorld(&gworld, 1, &r, NULL, NULL, keepLocal);	if(error) mexErrMsgTxt("NewGWorld/UpdateGWorld error.");	SetGWorld(gworld,NULL);//	TextFace(fontName);	GetFNum(c2pstr(fontName), &fnum);	TextFont(fnum);	TextSize(size);	// draw the sting there	EraseRect(&gworld->portRect);	MoveTo(0,0);	TETextBox(s, strlen((char *)s), box, justify);	bounds = *box;	// we could get fancy here and compute the exact bounds (see  Pelli's 'StringBounds.c')	// copy the GWorld bitmap to our bitmap	cols = bounds.right - bounds.left;	rows = bounds.bottom - bounds.top;	*bitmap = (unsigned long *)mxMalloc(rows * cols * sizeof(unsigned long));	if (*bitmap == NULL) mexErrMsgTxt("out of memory.");		pmHnd = GetGWorldPixMap(gworld);	LockPixels(pmHnd);	pixPtr = (unsigned char *)GetPixBaseAddr(pmHnd);	rowBytes = (*pmHnd)->rowBytes & 0x3fff;	for (i=0; i < rows; i++)		for (j=0; j<cols; j++)			(*bitmap)[i*cols+j] = pixPtr[i*rowBytes+j];			// ASSUMES 8-BIT PIXELS!	// clean up	UnlockPixels(pmHnd);	SetGWorld(old,oldDevice);	DisposeGWorld(gworld);}void mexFunction(                 int nlhs,       mxArray *plhs[],                 int nrhs, const mxArray *prhs[]		 ){	char *inStrPtr, fontName[24];	unsigned long *bitmap;	int rows, cols, textSize, textJustify;	int error, pixelSize, length, i, j;	double *outPtr, *rectPtr;	Rect textRect;		pixelSize = 8; // assumes 8-bit pixels		/* Check for proper number of arguments */	if (nrhs < 2 || nrhs > 5) {		mexErrMsgTxt("DrawText2Bitmap requires 3 - 5 input arguments.");	} else if (nlhs > 1) {		mexErrMsgTxt("DrawText2Bitmap requires one output argument.");	}	// ensure first input is a string	if (mxIsChar(prhs[0]) != 1) {		mexErrMsgTxt("First input must be a string!");	}	if (mxGetM(prhs[0]) != 1) {		mexErrMsgTxt("First input must be a row vector!");	}	// ensure second input is a rect (vector of length 4)	if (mxGetM(prhs[0]) != 1 && mxGetN(prhs[0]) != 4) {		mexErrMsgTxt("Second input must be a row vector of length 4!");	}	rectPtr = mxGetPr(prhs[1]);	// Copy input rect to a Rect struct	textRect.top = rectPtr[0];	textRect.left = rectPtr[1];	textRect.right = rectPtr[2];	textRect.bottom = rectPtr[3];	if (nrhs < 3)		textSize = 12;	else		textSize = *mxGetPr(prhs[2]);	strcpy(fontName, "geneva");	if (nrhs >= 4){		error = mxGetString(prhs[3], fontName, sizeof(fontName));		if (error != 0) mexWarnMsgTxt("Trouble reading font name from input- will use default.");	}	length = mxGetN(prhs[0]) + 1;	if (nrhs < 5)		textJustify = 0;	// default to left	else		textJustify = *mxGetPr(prhs[4]);		// Copy input string to a c-string	inStrPtr = mxCalloc(length, sizeof(char));	error = mxGetString(prhs[0], inStrPtr, length);	if (error != 0) mexWarnMsgTxt("Memory shortage- String is truncated.");	/* Do the actual computations in a subroutine */	DrawText2Bitmap((const unsigned char *)inStrPtr, pixelSize, &bitmap,  					&textRect, textSize, fontName, textJustify);	// copy output to a matrix	cols = textRect.right - textRect.left;	rows = textRect.bottom - textRect.top;	plhs[0] = mxCreateDoubleMatrix(rows, cols, mxREAL);	outPtr = mxGetPr(plhs[0]);	for (i=0; i<rows; i++)		for (j=0; j<cols; j++)			outPtr[i+j*rows] = bitmap[i*cols+j];	mxFree(bitmap);	return;}