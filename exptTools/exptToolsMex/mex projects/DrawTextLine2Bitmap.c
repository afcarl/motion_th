/*	bitmap = DrawTextLine2Bitmap(textString, textSize, fontName, justification)			textString = matlab string (row vector of chars)		textSize = font size in points (e.g., 12)		fontName = matlab string (try 'geneva', 'courier', 'new york', monaco', etc.		justification = -1 for right, 0 for left, 1 for center*/#include <Strings.h>	// c2pstr() and p2cstr()#include <stdlib.h>#include <stdio.h>#include <string.h>#include "mex.h"#include <Quickdraw.h>#include <Fonts.h>#include <QDOffscreen.h>#include <TextEdit.h>static void DrawTextLine2Bitmap(const unsigned char *s, int pixelSize, unsigned long **bitmap, 				int *rowsPtr, int *colsPtr, int size, const char *fontName, int justify);static void DrawTextLine2Bitmap(const unsigned char *s, int pixelSize, unsigned long **bitmap, 				int *rowsPtr, int *colsPtr, int size, const char *fontName, int justify)// some code lifted from Pelli's 'StringBounds' in 'StringBounds.c'{	GWorldPtr gworld=NULL;	GWorldPtr old;	GDHandle oldDevice;	FontInfo f;    Rect r, bounds;    long inkArea, rowBytes;	int error, rows, cols, i, j, oldTxSize;	short fnum;	char string[40];	PixMap **pmHnd;	unsigned char *pixPtr;	GetGWorld(&old,&oldDevice);	c2pstr((char *)s);		// set the old port with our font info so that we can determine the line width	TextSize(size);	GetFNum(c2pstr(fontName), &fnum);	TextFont(fnum);	TextSize(size);	GetFontInfo(&f);	SetRect(&r, 0, -f.ascent, StringWidth(s) ,f.descent);	// nominal size	InsetRect(&r, -(f.widMax+2), -(f.leading+2)); 		// add margin	// now that we're done, reset the old port	TextSize(old->txSize);		TextFont(old->txFont);	// create a new GWorld	error = NewGWorld(&gworld,pixelSize,&r,NULL,NULL,keepLocal|useTempMem);	if(error) error = NewGWorld(&gworld, 1, &r, NULL, NULL, keepLocal);	if(error) mexErrMsgTxt("NewGWorld/UpdateGWorld error.");	SetGWorld(gworld,NULL);	// set font info for the new GWorld	TextFont(fnum);	TextSize(size);	// Draw our line of text there	EraseRect(&gworld->portRect);	MoveTo(0,0);	DrawString(s);	bounds = r;	// we could get fancy here and compute the exact bounds (see  Pelli's 'StringBounds.c')	// copy the GWorld bitmap to our bitmap	cols = *colsPtr = bounds.right - bounds.left;	rows = *rowsPtr = bounds.bottom - bounds.top;	*bitmap = (unsigned long *)mxMalloc(rows * cols * sizeof(unsigned long));	if (*bitmap == NULL) mexErrMsgTxt("out of memory.");		pmHnd = GetGWorldPixMap(gworld);	LockPixels(pmHnd);	pixPtr = (unsigned char *)GetPixBaseAddr(pmHnd);	rowBytes = (*pmHnd)->rowBytes & 0x3fff;	for (i=0; i < rows; i++)		for (j=0; j<cols; j++)			(*bitmap)[i*cols+j] = pixPtr[i*rowBytes+j];			// ASSUMES 8-BIT PIXELS!	// clean up	UnlockPixels(pmHnd);	SetGWorld(old,oldDevice);	DisposeGWorld(gworld);}void mexFunction(                 int nlhs,       mxArray *plhs[],                 int nrhs, const mxArray *prhs[]		 ){	char *inStrPtr, fontName[24];	unsigned long *bitmap;	int rows, cols, textSize, textJustify;	int error, pixelSize, length, i, j;	double *outPtr;		pixelSize = 8;	// assumes 8-bit pixels		/* Check for proper number of arguments */	if (nrhs < 1 || nrhs > 4) {		mexErrMsgTxt("DrawTextLine2Bitmap requires 1 - 4 input arguments.");	} else if (nlhs > 1) {		mexErrMsgTxt("DrawTextLine2Bitmap requires one output argument.");	}	// ensure first input is a string	if (mxIsChar(prhs[0]) != 1) {		mexErrMsgTxt("First input must be a string!");	}	if (mxGetM(prhs[0]) != 1) {		mexErrMsgTxt("First input must be a row vector!");	}	length = mxGetN(prhs[0]) + 1;	if (nrhs < 2)		textSize = 12;	else		textSize = *mxGetPr(prhs[1]);	strcpy(fontName, "geneva");	if (nrhs >= 3){		error = mxGetString(prhs[2], fontName, sizeof(fontName));		if (error != 0) mexWarnMsgTxt("Trouble reading font name from input- will use default.");	}	length = mxGetN(prhs[0]) + 1;	if (nrhs < 4)		textJustify = 0;	// default to left	else		textJustify = *mxGetPr(prhs[3]);		// Copy input string to a c-string	inStrPtr = mxCalloc(length, sizeof(char));	error = mxGetString(prhs[0], inStrPtr, length);	if (error != 0) mexWarnMsgTxt("Memory shortage- String is truncated.");	/* Do the actual computations in a subroutine */	DrawTextLine2Bitmap((const unsigned char *)inStrPtr, pixelSize, &bitmap, &rows, &cols, 						textSize, fontName, textJustify);	// copy output to a matrix	plhs[0] = mxCreateDoubleMatrix(rows, cols, mxREAL);	outPtr = mxGetPr(plhs[0]);	for (i=0; i<rows; i++)		for (j=0; j<cols; j++)			outPtr[i+j*rows] = bitmap[i*cols+j];	mxFree(bitmap);	return;}