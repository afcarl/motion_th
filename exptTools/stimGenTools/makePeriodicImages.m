function img = createPeriodicImages(display,params,cmapRange)% % AUTHOR:  Press% DATE:    99.03.04% PURPOSE:%   createPeriodicImages creates images, as determined by the contents of% params.  See createPeriodicStimuli for an explanation of the relevent fields.%% cmapRange is the range of colormap values that the image should subtend.% This is particularly relevent for creating binocular images, when you might% want one eye's stimulus to subtend the bottom half of the colormap and the% other eye's stimulus to subtend the top half of the colormap.  Again, this% can be left out if you'd like to use the default full range (minus the small% number of reserved values).% Create default cmapRange if not passed inif ~exist('cmapRange')  loVal = max([display.reservedColor(:).fbVal])+1;  cmapRange = loVal:(display.numColors-1);end% shape, size, and type must be present, regardless.if ~isfield(params,'shape')    error('shape must be present in params');else    shape = params.shape;endif ~(strcmp(shape,'circle') | strcmp(shape,'rectangle') | strcmp(shape,'annulus'))    error('shape must be either a circle, rectangle, or annulus.');endif ~isfield(params,'size')	error('size must be present in params');else	stimSize = params.size;	if strcmp(shape,'annulus') & (stimSize(2)>=stimSize(1)/2)		error('The width of the annulus is greater than the outer radius.');	endendif ~isfield(params,'type')	error('type must be present in params');else	type = params.type;endif ~(strcmp(type,'linear') | strcmp(type,'circular') | strcmp(type,'dartboard') | strcmp(type,'solid') | strcmp(type,'blank'))    error('type must be either linear, circular, dartboard, solid, or blank.');end% spatial infoif ~(strcmp(type,'solid') | strcmp(type,'blank'))	if ~isfield(params,'spatial')		error('spatial paramaters must be specified for non-solid stimuli.')	end	if ~isfield(params.spatial,'modulation')		error('spatial.modulation must be present in params');	else		spatial.modulation = params.spatial.modulation;	end	if ~(strcmp(spatial.modulation,'sinusoidal') | strcmp(spatial.modulation,'square'))		error('spatial.modulation must be either sinusoidal or square.');	end	if ~isfield(params.spatial,'frequency')		error('spatial.frequency must be specified.');	else		spatial.frequency = params.spatial.frequency;	end		if ~isfield(params.spatial,'phase')		spatial.phase = 0;	else		spatial.phase = params.spatial.phase;	end		% stimulus-specific parameters		if (strcmp(type, 'linear'))		if ~isfield(params.spatial,'linear')			error('params.spatial must have a linear field for a linear stimulus');		end		if ~isfield(params.spatial.linear,'orientation')			error('params.spatial.linear must have an orientation field.');		else			spatial.orientation = params.spatial.linear.orientation;		end	elseif (strcmp(type, 'dartboard'))		if ~isfield(params.spatial,'dartboard')			error('params.spatial must have a dartboard field for a dartboard stimulus.');		end		if ~isfield(params.spatial.dartboard,'frequency')			error('params.spatial.dartboard must have a frequency field');		else			spatial.dartboard.frequency = params.spatial.dartboard.frequency;		end		if ~isfield(params.spatial.dartboard,'phase')			spatial.dartboard.phase = 0;		else			spatial.dartboard.phase = params.spatial.dartboard.phase;		end		if ~isfield(params.spatial.dartboard,'magFlag')			spatial.dartboard.magFlag = 0;		else			spatial.dartboard.magFlag = params.spatial.dartboard.magFlag;		end	endend% spatial envelopesif isfield(params,'spatial')	if isfield(params.spatial,'envelope')		if ~isfield(params.spatial.envelope,'shape')			error('spatial.envelope must have a shape');		else			spatial.envelope.shape = params.spatial.envelope.shape;		end		if ~(strcmp(spatial.envelope.shape,'gaussian') | strcmp(spatial.envelope.shape,'raisedcos') | strcmp(spatial.envelope.shape,'none'))			error('spatial.envelope.shape must be gaussian or raisedcos');		end		if strcmp(spatial.envelope.shape,'raisedcos') & ~strcmp(shape,'circle')			error('Raised cosine spatial envelope only available for circles');		end		if ~strcmp(spatial.envelope.shape,'none')			if ~isfield(params.spatial.envelope,'size')				error('spatial.envelope must have a size.');			else				spatial.envelope.size = params.spatial.envelope.size;			end		else			spatial.envelope.size = 0;		end	else		spatial.envelope.shape = 'none';		spatial.envelope.size = 0;	endelse	spatial.envelope.shape = 'none';	spatial.envelope.size = 0;endif length(spatial.envelope.size)==1	spatial.envelope.size(2) = spatial.envelope.size;end% temporal parametersif ~isfield(params,'temporal')	error('temporal paramaters must be specified.')endif ~isfield(params.temporal,'imgDirFlag')	temporal.imgDirFlag = 1;else	temporal.imgDirFlag = params.temporal.imgDirFlag;endif ~isfield(params.temporal,'modulation')	error('temporal.modulation must be present in params');else	temporal.modulation = params.temporal.modulation;endif ~(strcmp(temporal.modulation,'flickerSinusoid') | strcmp(temporal.modulation,'flickerSquare') | strcmp(temporal.modulation,'drift') | strcmp(temporal.modulation,'static'))	error('temporal.modulation must be either flickerSinusoid, flickerSquare, drift, or static.');endif isfield(params.temporal,'memoryFlag')	temporal.memoryFlag = params.temporal.memoryFlag;else	temporal.memoryFlag = 0;end	if strcmp(temporal.modulation,'drift')		if strcmp(type,'dartboard')		error('Dartboard stimulus cannot drift.');	end		if ~isfield(params.temporal,'frequency')		error('temporal.frequency must be present.');	else		temporal.frequency = params.temporal.frequency;	end			if ~strcmp(spatial.envelope.shape,'none')		% If bit-blitting...		if ~isfield(params.temporal,'phase')			temporal.phase = 0;		else			temporal.phase = params.temporal.phase;		end			if ~isfield(params,'duration')			error('Must provide a stimulus duration.');		else			duration = params.duration;		end			[framesPerCycle framesPerTrial] = getFramesPer(display, params);			% RFD: added memory flag check		if temporal.memoryFlag			numImages = min([framesPerCycle framesPerTrial]);		else			numImages = framesPerTrial;		end				time = linspace(0,min([1/temporal.frequency duration]),numImages+1);		else											% otherwise...		numImages = 1;	endelse	numImages = 1;end% noise parametersif isfield(params,'noise')	if isfield(params.noise,'type')		noise.type = lower(params.noise.type);	else		noise.type = 'uniform';	end	if isfield(params.noise,'level')		noise.level = params.noise.level;	else		error('params.noise must have a ''level'' field!');	end	if ~(strcmp(noise.type,'gaussian') | strcmp(noise.type,'uniform'))		error('params.noise.type must be either gaussian or uniform.');	endelse	noise.type = 'uniform';	noise.level = 0;endif ~isfield(params,'angularRange')	angularRange = [];else	angularRange = params.angularRange;endif ~isfield(params,'radialRange')	radialRange = [];else	radialRange = params.radialRange;endif ~isfield(params,'blank')	blank.shape = 'none';else	if ~isfield(params.blank,'shape')		error('params.blank needs a shape (I recommend a rectangle)');	else		blank.shape = params.blank.shape;	end	if ~strcmp(blank.shape,'rectangle')		error('params.blank.shape must be a rectangle');	end	if ~isfield(params.blank,'size')		error('params.blank needs a size');	else		blank.size = params.blank.size;	end	if ~isfield(params.blank,'offset')		blank.offset = [0 0];	else		blank.offset = params.blank.offset;	endend% Get the image dimensions.  Make sure there are an odd number of pixels, so% that the center of the image has its own pixel (important for substituting% submatrices, as is done in addAnnuli, for example).if (strcmp(shape,'circle') | strcmp(shape,'annulus'))	xsize = stimSize(1);	ysize = stimSize(1);else	xsize = stimSize(1);	ysize = stimSize(2);endnRow = 2*floor(angle2pix(display,ysize)/2)+1;nCol = 2*floor(angle2pix(display,xsize)/2)+1;img = zeros(nRow, nCol, numImages);% Create an initial flat template image expressed as the position relative to% the center of the image in degrees.yDeg = linspace(-ysize/2, ysize/2, nRow);xDeg = linspace(-xsize/2, xsize/2, nCol);[x y] = meshgrid(xDeg, yDeg);% Create a distance image.  This is used in the radial images and for cookie-% cutting all images to a circle, if necessary.dist = sqrt(x.^2 + y.^2);theta = atan2 (y, x);					% atan2 returns values between -pi and pitheta(theta<0) = theta(theta<0)+2*pi;	% correct range to be between 0 and 2*pi% Create the images.fprintf(' Creating %d image(s)', numImages);for frameNum = 1:numImages		% Create the type-dependent image function	if strcmp(type,'linear')		img(:,:,frameNum) = x*cos(spatial.orientation)+ y*sin(spatial.orientation);	elseif strcmp(type,'circular')		img(:,:,frameNum) = dist;	elseif strcmp(type,'dartboard')		if ~spatial.dartboard.magFlag			r = dist;		else			r = log(dist)/0.063;		end		img(:,:,frameNum) = sin(2*pi*r*spatial.frequency+spatial.phase) .* ...							sin(theta*spatial.dartboard.frequency+spatial.dartboard.phase);	elseif strcmp(type,'solid')		img(:,:,frameNum) = ones(size(dist));	else		img = zeros([size(dist) numImages]);		break;	end	if (strcmp(temporal.modulation,'drift') & strcmp(spatial.envelope.shape,'none'))		% If drifting with no gaussian envelope, turn it into a sawtooth image		% by mod-ing by degrees/cycle.  Multiply by spatial.frequency to scale from		% zero to one.  Then scale to the cmapRange.		img(:,:,frameNum) = img(:,:,frameNum) + spatial.phase/(2*pi*spatial.frequency);		img(:,:,frameNum) = mod (img(:,:,frameNum), 1/spatial.frequency) * spatial.frequency;		if (temporal.imgDirFlag & temporal.frequency < 0)			img(:,:,frameNum) = 1 - img(:,:,frameNum);		end			% add noise, if requested		img(:,:,frameNum) = addNoise(img(:,:,frameNum), noise);				img(:,:,frameNum) = (cmapRange(size(cmapRange,2))-cmapRange(1)) * img(:,:,frameNum) + cmapRange(1);	else		% If static, bit-blitting, or counterphase flickering, turn image into		% the real thing, envelope if necessary, and scale the image		% keeping zero smack dab in the middle of the colormap (by scaling		% symmetrically).  If counterphase flickering the sinusoid need not		% take into account the temporal information.		if ~(strcmp(type,'dartboard') | strcmp(type,'solid'))			if (strcmp(temporal.modulation,'static') | strncmp(temporal.modulation,'flicker',7))				img(:,:,frameNum) = cos(2*pi*(spatial.frequency*img(:,:,frameNum)) + ...										spatial.phase);			else				img(:,:,frameNum) = cos(2*pi*(spatial.frequency*img(:,:,frameNum) + ...						temporal.frequency*time(frameNum)) + spatial.phase+temporal.phase);			end		end				if isfield(spatial,'modulation')			if strcmp(spatial.modulation,'square') % [-1,1]->[0,1]->[-1,1]->[-0.5,0.5]				img(:,:,frameNum) = sign(round(img(:,:,frameNum)/2+0.5)*2-1)/2;			end		end			% add noise, if requested		img(:,:,frameNum) = addNoise(img(:,:,frameNum), noise);				if strcmp(spatial.envelope.shape,'gaussian')			if ~strcmp(shape,'annulus')				env = exp(-(1/2)*((x/spatial.envelope.size(1)).^2 + (y/spatial.envelope.size(2)).^2));				env = env/max(env(:));				img(:,:,frameNum) = img(:,:,frameNum) .* env;			else				midRadius = stimSize(1)/2 - stimSize(2)/2;				env = exp(-(1/2)*(((dist-midRadius)/spatial.envelope.size(1)).^2));				env = env/max(env(:));				img(:,:,frameNum) = img(:,:,frameNum) .* env;			end		elseif strcmp(spatial.envelope.shape,'raisedcos')			if ~strcmp(shape,'annulus')				env = (cos(2*pi*(dist-spatial.envelope.size/2)*(1/(2*(xsize/2-spatial.envelope.size/2))))+1)/2;				env = env .* (dist>=spatial.envelope.size/2 & dist<=xsize/2);				env = env + (dist<spatial.envelope.size/2);				img(:,:,frameNum) = img(:,:,frameNum) .* env;			else				% Code for an annulus with a raised cosine spatial envelope will go here.				% Make sure you get rid of the error message barring this combination				% towards the top of the function, should you try to implement this.			end		end				thisImg = img(:,:,frameNum);		maxAbsImgVal = max(abs(thisImg(:)));		img(:,:,frameNum) = scale(img(:,:,frameNum), cmapRange(1), ...			cmapRange(size(cmapRange,2)), -maxAbsImgVal, maxAbsImgVal);	end	% Cut image to a circle or annulus	if strcmp(shape,'circle')		circMask = (dist <= stimSize(1)/2);		img(:,:,frameNum) = img(:,:,frameNum) .* circMask;	elseif strcmp(shape,'annulus')		circMask = (dist <= stimSize(1)/2) & (dist >= (stimSize(1)/2-stimSize(2)));		img(:,:,frameNum) = img(:,:,frameNum) .* circMask;	end    % Limit image to angularRange, if it exists    	if ~isempty(angularRange)        if angularRange(1) < 0            img(:,:,frameNum) = img(:,:,frameNum) .* ...		      (theta>=mod(angularRange(1),2*pi) | theta<=angularRange(2));        elseif angularRange(2) > 2*pi           img(:,:,frameNum) = img(:,:,frameNum) .* ...		      (theta>=angularRange(1) | theta<=mod(angularRange(2),2*pi));        else 	 	   img(:,:,frameNum) = img(:,:,frameNum) .* ...		      (theta>=angularRange(1) & theta<=angularRange(2));        end	end    % Limit image to radialRange, if it exists    	if ~isempty(radialRange) 		img(:,:,frameNum) = img(:,:,frameNum) .* ...		      	(dist>=radialRange(1) & dist<=radialRange(2));	end    % Blank middle of image, if blank.size exists        if ~strcmp(blank.shape,'none')        img(:,:,frameNum) = img(:,:,frameNum) .* ...		      ~(abs(y-blank.offset(2))<=blank.size(2)/2 & abs(x-blank.offset(1))<=blank.size(1)/2);    end		fprintf('.');endfprintf('\n');return;function img = addNoise(img,noise)% adds noise to the 1 or 2d matrix 'img'if noise.level ~= 0	if strcmp(noise.type,'gaussian')		% normally distributed noise- noise level is the standard deviation of the noise		% The mean of the noise 0, so the noise is added and subtracted from the image.		% Note that the intensities are clipped to remain within the bounds (0,1), so		% a very large standard deviation (noise level) will result in an image that is		% pure binary noise.		img = (1-noise.level).*img + noise.level.*randn(size(img));	else		% uniformly distributed noise- noise level is the proportion of noise-to-signal		img = (1-noise.level).*img + noise.level.*(.5-randn(size(img)));	end	% ensure that we don't go out-of-bounds due to rounding error%	img(img>oldRange(2)) = oldRange(2);%	img(img<oldRange(1)) = oldRange(1);end		