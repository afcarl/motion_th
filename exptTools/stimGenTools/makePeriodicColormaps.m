function [cmap,gamma] = createPeriodicColormaps(display, params, cmapRange, cmap);% % AUTHOR:  Press% DATE:    99.03.04% PURPOSE:%   Creates a counterphase flickering colormap for a stimulus% struct.  This colormap range will be restricted to cmapRange,% so that the colormap can be split.  This routine can be called% without providing either a colormap to begin with (it will% initialize one for you) or a colormap range (it will% use all but the reserved values).%% If you call this routine with two output arguments (e.g.,% [cmap,gamma] = createPeriodicColormaps(yadayadayada)), this% code will check to see if you're using 10 bit DACs and, if% so, will transform the colormap using tenBit2eightBit.  Otherwise,% it will return an empty gamma.%% If you are going to split the colormap, you will call this routine% more than once, sending in the cmap on calls subsequent to the% first.  It is important, then, that you NOT transform the cmap% with tenBit2eightBit until the final call!  Thus, all calls% but the last should return the cmap ONLY.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% Read the parameters.  Use defaults for those that do not     %% exist.                                                       %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~isfield(params,'type')	error('type must be present in params');else	type = params.type;endif ~(strcmp(type,'linear') | strcmp(type,'circular') | strcmp(type,'dartboard') | strcmp(type,'solid') | strcmp(type,'blank'))    error('type must be either linear, circular, dartboard, solid, or blank.');endif ~isfield(params,'temporal')	error('temporal paramaters must be specified.')endif ~isfield(params.temporal,'modulation')	error('temporal.modulation must be present in params');else	temporal.modulation = params.temporal.modulation;endif ~(strcmp(temporal.modulation,'flickerSinusoid') | strcmp(temporal.modulation,'flickerSquare') | strcmp(temporal.modulation,'drift') | strcmp(temporal.modulation,'static'))	error('temporal.modulation must be either flickerSinusoid, flickerSquare, drift, or static.');endif strcmp(temporal.modulation,'drift')	if ~isfield(params,'spatial')		error('Must have spatial parameters if drifting a stimulus.');	end	if ~isfield(params.spatial,'modulation')		error('spatial.modulation must be present in params');	else		spatial.modulation = params.spatial.modulation;	endendif isfield(params,'spatial')	if isfield(params.spatial,'envelope')		if ~isfield(params.spatial.envelope,'shape')			error('spatial.envelope must have a shape');		else			spatial.envelope.shape = params.spatial.envelope.shape;		end	else		spatial.envelope.shape = 'none';	endelse	spatial.envelope.shape = 'none';end% temporal stuffif isfield(params.temporal,'envelope')	if ~isfield(params.temporal.envelope,'shape')		error('temporal.envelope must have a shape');	else		temporal.envelope.shape = params.temporal.envelope.shape;	end	if ~(strcmp(temporal.envelope.shape,'gaussian') | strcmp(temporal.envelope.shape,'raisedcos') | strcmp(temporal.envelope.shape,'none'))		error('temporal.envelope.shape must be gaussian or raisedcos');	endelse	temporal.envelope.shape = 'none';endif ~strcmp(temporal.envelope.shape,'none') & ~strcmp(spatial.envelope.shape,'none') & strcmp(temporal.modulation,'drift')	error('You cannot have a temporal envelope when doing bit-blit animation.');endif (strcmp(temporal.modulation,'static') & strcmp(temporal.envelope.shape,'none')) | ...   (strcmp(temporal.modulation,'drift') & ~strcmp(temporal.envelope.shape,'none'))		% If static image or bit-blitting...		numCmaps = 1;	temporal.window = 1;else												% otherwise...		if ~isfield(params,'duration')		error('Must provide a stimulus duration.');	else		duration = params.duration;	end		if ~isfield(params.temporal,'frequency')		if strcmp(temporal.modulation,'static')			params.temporal.frequency = 1/duration;		else			error('temporal.frequency must be present.');		end	end	temporal.frequency = params.temporal.frequency;	if ~isfield(params.temporal,'imgDirFlag')		temporal.imgDirFlag = 0;	else		temporal.imgDirFlag = params.temporal.imgDirFlag;	end	if temporal.imgDirFlag		temporal.frequency = abs(temporal.frequency);	end			if ~isfield(params.temporal,'phase')		temporal.phase = 0;	else		temporal.phase = params.temporal.phase;	end	[framesPerCycle framesPerTrial] = getFramesPer(display, params);	if isfield(params.temporal,'memoryFlag')		temporal.memoryFlag = params.temporal.memoryFlag;	else		temporal.memoryFlag = 0;	end	if temporal.memoryFlag			numCmaps = framesPerCycle;		time = linspace(0, 1/temporal.frequency, numCmaps+1);	else		numCmaps = framesPerTrial;		time = linspace(0, duration, numCmaps+1);	end				if strcmp(temporal.envelope.shape,'none')		temporal.window = ones(1,numCmaps);	else		if temporal.memoryFlag			error('You cannot use a temporal envelope when the memoryFlag is set.');		end		if strcmp(temporal.envelope.shape,'gaussian')			if ~isfield(params.temporal.envelope,'size')				temporal.envelope.size = duration/6;			else				temporal.envelope.size = params.temporal.envelope.size;			end			temporal.envelope.fraction = temporal.envelope.size/duration;			temporal.window = exp(-.5*(([.5:numCmaps]-numCmaps/2) ./ (temporal.envelope.fraction*numCmaps)).^2);		else			if ~isfield(params.temporal.envelope,'size')				temporal.envelope.size = 0.9*duration;			else				temporal.envelope.size = params.temporal.envelope.size;			end			endSize = (duration-temporal.envelope.size)/2;			endWindow = (cos(2*pi*time(time<endSize)/(2*endSize))+1)/2;			beginWindow = fliplr(endWindow);			midWindow = ones(1,numCmaps-2*length(endWindow));			temporal.window = [beginWindow midWindow endWindow];		end	endendif isfield(params,'stimRGB')	stimRGB = params.stimRGB;elseif isfield(params,'stimLMS')	if isfield(params,'backRGB')		stimRGB = cone2RGB(display, params.stimLMS, params.backRGB);	else		stimRGB = cone2RGB(display, params.stimLMS);	endelse	stimRGB.dir = [1 1 1]';	stimRGB.scale = 0.5;endstimRGB.dir = stimRGB.dir(:);	% Force stimRGB.dir to be a column vectorif isfield(params,'backRGB')	background = params.backRGB.scale * params.backRGB.dir';else	background = [0.5 0.5 0.5];end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% Initialize the color ranges if they do not already exist.	   %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if nargin < 4	cmap = zeros(display.numColors,3,numCmaps);	if (nargin < 3)		minVal = max([display.reservedColor(:).fbVal])+1;		maxVal = display.numColors-1;		cmapRange = (minVal:maxVal)+1;	endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% compute the maximum value for the color map's R, G and B.	   %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%maxRGBValue = 2^display.cmapDepth-1;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% Create colormaps.									           %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if strcmp(type,'blank')		cmap(cmapRange,1:3) = repmat(background * maxRGBValue,length(cmapRange),1);elseif strcmp(temporal.modulation,'static') | (strcmp(temporal.modulation,'drift') & ...									 		   ~strcmp(spatial.envelope.shape,'none'))		% Bit blitting or showing static stimuli		ramp = [linspace(-1,1,size(cmapRange,2))]';			for frameNum = 1:numCmaps 	  	cmap(cmapRange,:,frameNum) = ...			(stimRGB.scale * temporal.window(frameNum) * ramp * ...			 ones(1,3) * diag(stimRGB.dir'./max(abs(stimRGB.dir))) + ...			 repmat(background,size(cmapRange,2),1)) * maxRGBValue;	endelseif (strcmp(temporal.modulation,'drift') & strcmp(spatial.envelope.shape,'none'))	% Drift cmap animation	ramp = [linspace(0,1,size(cmapRange,2)+1)]';	ramp = ramp(1:size(cmapRange,2));	for frameNum = 1:numCmaps 		timeDependency = sin(2*pi*(ramp-temporal.frequency*time(frameNum))+temporal.phase);									if strcmp(spatial.modulation,'square') % [-1,1]->[0,1]->[-1,1]			timeDependency = sign(round(timeDependency/2+0.5)*2-1);		end				cmap(cmapRange,:,frameNum) = ...			(stimRGB.scale * temporal.window(frameNum) * timeDependency * ...			 ones(1,3) * diag(stimRGB.dir'./max(abs(stimRGB.dir))) + ...			 repmat(background,size(cmapRange,2),1)) * maxRGBValue;	end	elseif (strncmp(temporal.modulation,'flicker',7))			% Flicker cmap animation	ramp = [linspace(-1,1,size(cmapRange,2))]';	for frameNum = 1:numCmaps		timeDependency = sin(2*pi*temporal.frequency*time(frameNum)+temporal.phase);		if ~isempty(findstr(temporal.modulation,'Square')) % [-1,1]->[0,1]->[-1,1]			timeDependency = sign(round(timeDependency/2+0.5)*2-1);		end  		ct = stimRGB.scale*timeDependency;  		cmap(cmapRange,:,frameNum) = ...			(ct * temporal.window(frameNum) * ramp * ...			 ones(1,3) * diag(stimRGB.dir'./max(abs(stimRGB.dir))) + ...			 repmat(background,size(cmapRange,2),1)) * maxRGBValue;	endelse	error ('temporal.modulation must be either flickerSinusoid, flickerSquare, drift, or static');	end									cmap = floor(cmap);cmap = insertReservedCols(display,cmap);if ((display.cmapDepth==10) & (nargout > 1))	[cmap,gamma] = tenBit2eightBit(display,cmap);else	gamma = [];end