function cmap = generateColormaps(display, params, cmapRange, cmap);% THIS CODE IS OBSOLETE.  DO NOT USE.  SEE makePeriodicStimulus.%% AUTHOR:  Press% DATE:    7/30/98% PURPOSE:%   Creates a counterphase flickering colormap for a stimulus% struct.  This colormap range will be restricted to cmapRange,% so that the colormap can be split.  This routine can be called% without providing either a colormap to begin with (it will% initialize one for you) or a colormap range (it will% use all but the reserved values); however, if a colormap is not% provided, a range cannot be provided either.  Thus, if you% wish to pass in a colormap range but have not yet initilized a% colormap, set cmap = zeros(display.numColors, 3, <numFrames>)% before calling this routine.%% Originally adapted from makeCounterphaseGrating.m and% makeFlickerCmap.m.  A critical difference is that the colormap% is essentially a linear ramp -- shapes, such as a sinusoid for a% grating, must be made as part of the image.  In contrast,% Geoff's code had the color map as a sinusoid, assuming that one% would then want to make a grating using a linear ramp as the% image.%% DETAILS:%   temporalEnvelope = 'gauss': adds a temporal envelope where the%           FWHM is .395*duration (contrast goes to ~0.015 of max%           at the bounds)%                   %% 98.10.??    RFD: added code to do a Gaussian temporal window% 98.12.03    RFD: added comments for the temporal window code%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% Read the parameters.  Use defaults for those that do not     %% exist.                                                       %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%disp('WARNING: generateColormaps is OBSOLETE and should not be used.');disp('see makePeriodicStimulus.');if ~isfield(params,'stimulusType')	error('stimulusType must be present in params');else	stimulusType = params.stimulusType;endif ~isfield(params,'temporalType')	error('temporalType must be present in params');else	temporalType = params.temporalType;endif ~isfield(params,'waveType')	error('waveType must be present in params');else	waveType = params.waveType;endif ~isfield(params,'envelopeType') & ~isfield(params,'spatialEnvelope')	error('spatialEnvelope must be present in params');else	if isfield(params,'spatialEnvelope')		spatialEnvelope = params.spatialEnvelope;	else % for backwards compatability		spatialEnvelope = params.envelopeType;	endendif ~isfield(params,'temporalEnvelope')	disp('Using default temporalEnvelope = ''none''.');	temporalEnvelope = 'none';else	temporalEnvelope = params.temporalEnvelope;endif (isfield(params,'coldir') & isfield(params,'contrast'))    coldir = params.coldir;    contrast = params.contrast;else    if isfield(params,'stimRGB')        coldir = params.stimRGB.dir';        contrast = params.stimRGB.scale;    elseif isfield(params,'stimLMS')        if isfield(params,'backRGB')            stimRGB = cone2RGB(display, params.stimLMS,params.backRGB);        else            stimRGB = cone2RGB(display, params.stimLMS);        end        coldir = stimRGB.dir';        contrast = stimRGB.scale;    else        if ~isfield(params,'coldir')	       disp('Using default color direction of [1 1 1]');	       coldir = [1 1 1];        else	       coldir = params.coldir;        end        if ~isfield(params,'contrast')	       disp('Using default contrast of 1.');	       contrast = 1;        else	       contrast = params.contrast;        end    endendif (strcmp(temporalEnvelope,'none') & strcmp(temporalType,'static') ...	| (strcmp(temporalType,'drift') & ~strcmp(spatialEnvelope,'none')))		% If static image or bit-blitting...		numCmaps = 1;	temporalWindow = 1;else												% otherwise...		if ~isfield(params,'temporalFrequency')		disp('Using default temporal frequency of one cycle/degree');		temporalFreq = 1;	else		temporalFreq = params.temporalFrequency;	end		if ~isfield(params,'temporalPhase')		disp('No temporal phase offset.');		temporalPhase = 0;	else		temporalPhase = params.temporalPhase;	end	if ~isfield(params,'duration')		error('duration must be present in params');	else		duration = params.duration;	end	[framesPerCycle framesPerTrial] = getFramesPer(display, params);	numCmaps = framesPerTrial;		time = linspace(0, duration, numCmaps+1);	if strcmp(temporalEnvelope,'none')		temporalWindow = ones(1,numCmaps);	elseif  strcmp(temporalEnvelope,'gauss') ...				| strcmp(temporalEnvelope,'gaussian')		temporalWindow = exp(-.5*(([.5:numCmaps]-numCmaps/2) ./ (numCmaps/6)).^2);        % these parameters will bring contrast to about 1% at the boundaries        % FWHM = .395*duration	else		disp(['Unknown temporalEnvelope ''' temporalEnvelope ''': defaulting to none.']);		temporalWindow = ones(1,numCmaps);	endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% Initialize the colormap if it does not already exist.  Same  %% for the color ranges.         			       			   %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if (nargin < 4)	cmap = zeros(display.numColors,3,numCmaps);	if (nargin < 3)		minVal = max([display.reservedColor(:).fbVal])+1;		maxVal = display.numColors-1;		cmapRange = (minVal:maxVal)+1;	endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% compute the maximum value for the color map's R, G abd B.	   %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%maxRGBValue = 2^display.cmapDepth-1;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                              %% Create colormaps.									           %%                                                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if strcmp(stimulusType,'blank')		cmap(cmapRange,1:3) = floor(maxRGBValue/2) * ones(length(cmapRange),3);elseif (strcmp(temporalType,'static') | (strcmp(temporalType,'drift') & ...									 ~strcmp(spatialEnvelope,'none')))		% Bit blitting or showing static stimuli		ramp = [linspace(-0.5,0.5,size(cmapRange,2))]';			for frameNum = 1:numCmaps 	  	cmap(cmapRange,:,frameNum) = (contrast * temporalWindow(frameNum) * ...							ramp * ones(1,3) * diag(coldir./max(abs(coldir))) + ...							0.5) * maxRGBValue;	endelseif (strcmp(temporalType,'drift') & strcmp(spatialEnvelope,'none'))	% Drift cmap animation	ramp = [linspace(0,1,size(cmapRange,2)+1)]';	ramp = ramp(1:size(cmapRange,2));	for frameNum = 1:numCmaps 		timeDependency = sin(2*pi*(ramp-temporalFreq*time(frameNum)) - ...							temporalPhase) / 2;									if strcmp(waveType,'square') % [-0.5,0.5]->[0,1]->[-1,1]->[-0.5,0.5]			timeDependency = sign(round(timeDependency+0.5)*2-1)/2;		end				cmap(cmapRange,:,frameNum) = ...			(contrast * temporalWindow(frameNum) * timeDependency * ones(1,3) * ...			 diag(coldir./max(abs(coldir))) + 0.5) * maxRGBValue;	end	elseif (strncmp(temporalType,'flicker',7))			% Flicker cmap animation	ramp = [linspace(-0.5,0.5,size(cmapRange,2))]';	for frameNum = 1:numCmaps		contrastSin = sin(2*pi*temporalFreq*time(frameNum)+temporalPhase);		if ~isempty(findstr(temporalType,'Square')) % [-1,1]->[0,1]->[-1,1]			contrastSin = sign(round(contrastSin/2+0.5)*2-1);		end  		ct = contrast*contrastSin;  		cmap(cmapRange,:,frameNum) = ...			(ct * temporalWindow(frameNum) * ramp * ones(1,3) * ...				diag(coldir./max(abs(coldir)))+0.5) * maxRGBValue;	endelse	error ('temporalType must be either flickerSinusoid, flickerSquare, drift, or static');	end									cmap = floor(cmap);cmap = insertReservedCols(display,cmap);