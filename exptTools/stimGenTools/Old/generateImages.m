function img = generateImages(display,params,cmapRange)% THIS CODE IS OBSOLETE.  DO NOT USE.  SEE makePeriodicStimulus.% % AUTHOR:  Press% DATE:    07.29.98% PURPOSE:%   generateImage creates an image, as determined by the contents of% params.  This image can be either linear (that is, a sin wave or a gabor)% or radial (that is, a circular harmonic function).  Also, the returned% variable img will contain either the shape of the function itself or a% sawtooth image.  This will depend upon the form of animation used.  This% will become more clear after taking a look at the params parameter.%% THIS IS OUT OF DATE.  See Users:press:binocular:paramsInitialize.m for example%% Params contains the basic information necessary for building the stimulus.% It should contain many of the following fields (the first 3 are mandatory):%%	stimulusType:		string		'linear' or 'radial'.%	temporalType:		string		'drift' (drifting grating), 'flicker'%									(for counterphase flicker), or 'static'%	size:				double		degrees.  Can either be a single value%									(for a circle's diameter) or two values (for%									a rectangle).%	spatialFrequency:	double		cycles/degree%	spatialPhase:		double		degrees%	orientation:		double		degrees.  Meaningful only for linear stimuli%	envelopeSD:			double		standard deviation of the gaussian envelope.%									This is used to make Gabors, for example.%									This can be set to zero or omitted, if so%									desired.%	temporalFrequency:	double		cycles/second%	temporalPhase:		double		seconds%% If the temporalType is 'drift' and there is no Gaussian envelope (envelopeSD% is either omitted or is set to zero), then the image will be a sawtooth image,% and the colormap, as set by generateCmap, will contain the sinusoid.  The% drifting will be effected by changing the phase of the sinusoid in the% colormap.  If the temporalType is 'drift' and there is a Gaussian envelope,% the animation will occur using bit-blitting: the image itself, and not the% colormap, will effect the animation.  Thus, in this case, the img will% contain the shape of the stimulus in toto (this is what the "time" variable% is for -- so that the phase of the stimulus reflects the time since% stimulus onset).  Finally, if the temporalType is 'flicker,' the img will% contain the shape of the stimulus, as in bit-bitting, but the animation will% be handled by the colormap.  In this way, counterphase flicker can be handled% using colormap animation even for Gaussian-enveloped stimuli.%% cmapRange is the range of colormap values that the image should subtend.% This is particularly relevent for creating binocular images, when you might% want one eye's stimulus to subtend the bottom half of the colormap and the% other eye's stimulus to subtend the top half of the colormap.  Again, this% can be left out if you'd like to use the default full range (minus the small% number of reserved values).% Create default cmapRange if not passed indisp('WARNING: generateImages is OBSOLETE and should not be used.');disp('see makePeriodicStimulus.');if ~exist('cmapRange')  loVal = max([display.reservedColor(:).fbVal])+1;  cmapRange = loVal:(display.numColors-1);end% Check for the presence of the appropriate params fields, and fill in% default values wherever possible.if ~isfield(params,'shapeType')    if length(params.size<2)        shapeType = 'circle';    else        shapeType = 'rectangle';    endelse    shapeType = params.shapeType;endif ~(strcmp(shapeType,'circle') | strcmp(shapeType,'rectangle') | strcmp(shapeType,'annulus'))    error('shapeType must be either a circle, rectangle, or annulus.');endif ~isfield(params,'stimulusType')	error('stimulusType must be present in params');else	stimulusType = params.stimulusType;endif ~isfield(params,'waveType')	error('waveType must be present in params');else	waveType = params.waveType;endif ~isfield(params,'envelopeType') & ~isfield(params,'spatialEnvelope')	error('spatialEnvelope must be present in params');else	if isfield(params,'spatialEnvelope')		spatialEnvelope = params.spatialEnvelope;	else % for backwards compatability		spatialEnvelope = params.envelopeType;	endendif ~isfield(params,'temporalType')	error('temporalType must be present in params');else	temporalType = params.temporalType;endif ~isfield(params,'size')	error('size must be present in params');else	imgSize = params.size;endif ~isfield(params,'spatialFrequency')	disp('Using defualt spatial frequency of one cycle/degree');	spatialFreq = 1;else	spatialFreq = params.spatialFrequency;endif ~isfield(params,'spatialPhase')	disp('No spatial phase offset.');	spatialPhase = 0;else	spatialPhase = params.spatialPhase;endif strcmp(spatialEnvelope, 'gaussian')	if ~isfield(params,'envelopeSD')		disp('No gaussian envelope!');		sd = 0;	else		sd = params.envelopeSD;		if length(sd)==1			sd(2)  = sd;		end	endelseif strcmp(spatialEnvelope, 'raisedcos')	if ~isfield(params,'beginEnv')		disp('Raised cos beginning in center of stimulus!');		beginEnv = 0;	else		beginEnv = params.beginEnv;	endendif ~isfield(params,'radialRange')	radialRange = [];else	radialRange = params.radialRange;endif ~isfield(params,'centerBlankRectangle')	centerBlankRectangle = [];else	centerBlankRectangle = params.centerBlankRectangle;endif (strcmp(stimulusType, 'linear'))	if ~isfield(params,'orientation')		disp('Using defaults orientation of zero degrees.');		orientation = 0;	else		orientation = params.orientation;	endelseif (strcmp(stimulusType, 'target'))	if strcmp(temporalType, 'drift')		error('Target stimulus cannot drift!');	end	if ~isfield(params,'radialFrequency')		error('Target stimulus must have radialFrequency.');	else		radialFreq = params.radialFrequency;	end	if ~isfield(params,'radialPhase')		disp('Using default radialPhase of 0.');		radialPhase = 0;	else		radialPhase = params.radialPhase;	endendif (strcmp(temporalType,'drift') & ~strcmp(spatialEnvelope,'none'))		% If bit-blitting...		if ~isfield(params,'temporalFrequency')		disp('Using default temporal frequency of one cycle/degree');		temporalFreq = 1;	else		temporalFreq = params.temporalFrequency;	end		if ~isfield(params,'temporalPhase')		disp('No temporal phase offset.');		temporalPhase = 0;	else		temporalPhase = params.temporalPhase;	end	if ~isfield(params,'duration')		error('Must provide a stimulus duration.');	else		duration = params.duration;	end	[framesPerCycle framesPerTrial] = getFramesPer(display, params);	numImages = min([framesPerCycle framesPerTrial]);	time = linspace(0,min([1/temporalFreq duration]),numImages+1);else											% otherwise...	numImages = 1;end% Get the image dimensions.  Make sure there are an odd number of pixels, so% that the center of the image has its own pixel (important for substituting% submatrices, as is done in addAnnuli, for example).if (strcmp(shapeType,'circle') | strcmp(shapeType,'annulus'))	ysize = imgSize(1);	xsize = imgSize(1);else	ysize = imgSize(1);	xsize = imgSize(2);endnRow = 2*floor(angle2pix(display,ysize)/2)+1;nCol = 2*floor(angle2pix(display,xsize)/2)+1;img = zeros(nRow, nCol, numImages);% Create an initial flat template image expressed as the position relative to% the center of the image in degrees.yDeg = linspace(-ysize/2, ysize/2, nRow);xDeg = linspace(-xsize/2, xsize/2, nCol);[x y] = meshgrid(xDeg, yDeg);% Create a distance image.  This is used in the radial images and for cookie-% cutting all images to a circle, if necessary.dist = sqrt(x.^2 + y.^2);theta = atan2 (y, x);					% atan2 returns values between -pi and pitheta(theta<0) = theta(theta<0)+2*pi;	% correct range to be between 0 and 2*pi% Create the images.fprintf(' Creating %d image(s)', numImages);for frameNum = 1:numImages		% Create the stimulusType-dependent image function	if (strcmp(stimulusType,'linear'))		img(:,:,frameNum) = x*cos(orientation)+ y*sin(orientation);	elseif (strcmp(stimulusType,'radial') | strcmp(stimulusType,'gauss') | strcmp(stimulusType,'gaussian'))		img(:,:,frameNum) = dist;	elseif (strcmp(stimulusType,'target'))		img(:,:,frameNum) = sin(2*pi*dist*spatialFreq+spatialPhase) .* ...							sin(theta*radialFreq+radialPhase);	else		error('stimulusType must be linear or radial');	end	if (strcmp(temporalType,'drift') & strcmp(spatialEnvelope,'none'))		% If drifting with no gaussian envelope, turn it into a sawtooth image		% by mod-ing by degrees/cycle.  Multiply by spatialFreq to scale from		% zero to one.  Then scale to the cmapRange.		img(:,:,frameNum) = img(:,:,frameNum) + spatialPhase/(2*pi*spatialFreq);		img(:,:,frameNum) = mod (img(:,:,frameNum), 1/spatialFreq) * spatialFreq;		img(:,:,frameNum) = (cmapRange(size(cmapRange,2))-cmapRange(1)) * img(:,:,frameNum) + cmapRange(1);	else		% If static, bit-blitting, or counterphase flickering, turn image into		% periodic (if not a gaussian -- this can be a stimulus type in and of		% itself, envelope notwithstanding), envelope if necessary, and scale the image		% keeping zero smack dab in the middle of the colormap (by scaling		% symmetrically).  If counterphase flickering the sinusoind need not		% take into account the temporal information.		if (strcmp(stimulusType,'gauss') | strcmp(stimulusType,'gaussian'))						img(:,:,frameNum) = exp(-0.5*(dist/(xsize/7)).^2);	% drops to 3.5 sd on either side					else					if ~strcmp(stimulusType,'target')				if (strcmp(temporalType,'static') | strncmp(temporalType,'flicker',7))					img(:,:,frameNum) = cos(2*pi*(spatialFreq*img(:,:,frameNum)) + ...											spatialPhase);				else					img(:,:,frameNum) = cos(2*pi*(spatialFreq*img(:,:,frameNum) + ...							temporalFreq*time(frameNum)) + spatialPhase+temporalPhase);				end			end						if strcmp(waveType,'square') % [-1,1]->[0,1]->[-1,1]->[-0.5,0.5]				img(:,:,frameNum) = sign(round(img(:,:,frameNum)/2+0.5)*2-1)/2;			end						if strcmp(spatialEnvelope,'gaussian')				env = exp(-(1/2)*((x/sd(2)).^2 + (y/sd(1)).^2));				env = env/max(env(:));				img(:,:,frameNum) = img(:,:,frameNum) .* env;			elseif strcmp(spatialEnvelope,'raisedcos')				env = (cos(2*pi*(dist-beginEnv)*(1/(2*(xsize/2-beginEnv))))+1)/2;				env = env .* (dist>=beginEnv & dist<=xsize/2);				env = env + (dist<beginEnv);				img(:,:,frameNum) = img(:,:,frameNum) .* env;			end				end				thisImg = img(:,:,frameNum);		maxAbsImgVal = max(abs(thisImg(:)));		img(:,:,frameNum) = scale(img(:,:,frameNum), cmapRange(1), ...			cmapRange(size(cmapRange,2)), -maxAbsImgVal, maxAbsImgVal);	end	% Cut image to a circle or annulus	if strcmp(shapeType,'circle')		circMask = (dist <= imgSize(1)/2);		img(:,:,frameNum) = img(:,:,frameNum) .* circMask;	elseif strcmp(shapeType,'annulus')		circMask = ((dist <= imgSize(1)/2) & (dist >= imgSize(2)/2));		img(:,:,frameNum) = img(:,:,frameNum) .* circMask;	end    % Limit image to radialRange, if it exists    	if ~isempty(radialRange)        if radialRange(1) < 0            img(:,:,frameNum) = img(:,:,frameNum) .* ...		      (theta>=mod(radialRange(1),2*pi) | theta<=radialRange(2));        elseif radialRange(2) > 2*pi           img(:,:,frameNum) = img(:,:,frameNum) .* ...		      (theta>=radialRange(1) | theta<=mod(radialRange(2),2*pi));        else 	 	   img(:,:,frameNum) = img(:,:,frameNum) .* ...		      (theta>=radialRange(1) & theta<=radialRange(2));        end	end    % Blank middle of image, if centerBlankRectangle exists        if ~isempty(centerBlankRectangle)        img(:,:,frameNum) = img(:,:,frameNum) .* ...		      ~(abs(y)<=centerBlankRectangle(1)/2 & abs(x)<=centerBlankRectangle(2)/2);    end		fprintf('.');endfprintf('\n');return;