function [trial, data] = GaborTrial(display, stimParams, data)% trial = GaborTrial(display, stimParams)backColor = display.reservedColor(findName(display.reservedColor,'background')).gunVal;backIndex = display.reservedColor(findName(display.reservedColor,'background')).fbVal;% Create colormap ranges.% Here, we divide the color map into two independant sections- one% for the left image and one for the right image.  This allows us to % draw only one image and use the color map to determine which is% seen.  Here are the details: minVal is the lowest available colormap% value, maxVal is the highest.  Tailor maxVal so the two cmaps% have the same (odd) number of entries (odd so the grayVal is% gray).  The first half of the usable range will be devoted to	% the left stimulus, the second half to the right stimulus.minVal = max([display.reservedColor(:).fbVal])+1;maxVal = display.numColors-1;if (mod(maxVal-minVal+1,2) == 1)  maxVal = maxVal - 1;endif (mod((maxVal-minVal+1)/2,2) == 0)  maxVal = maxVal - 2;endcmapIndicesLeft = minVal:(minVal+(maxVal-minVal+1)/2-1);cmapIndicesRight = (minVal+(maxVal-minVal+1)/2):maxVal;% we need 2 cmaps- one is blank (so that we can draw and erase invisibly)% and the other is crafted so as to display one of the two Gabors (left% or right, depending on stimParams.testPosition) at the desired% contrast.  numCmaps = 2;cmap = zeros(display.numColors,3,numCmaps);ramp = [linspace(-0.5,0.5,length(cmapIndicesLeft))]';	if stimParams.testPosition == 'L' 	cmap(cmapIndicesLeft+1,:,1) = floor((stimParams.test.contrast * ramp * ones(1,3) * ...						diag(stimParams.test.colorDir./max(abs(stimParams.test.colorDir))) + ...						0.5) * display.maxGunVal);	cmap(cmapIndicesRight+1,:,1) = floor((stimParams.stnd.contrast * ramp * ones(1,3) * ...						diag(stimParams.stnd.colorDir./max(abs(stimParams.stnd.colorDir))) + ...						0.5) * display.maxGunVal);else	cmap(cmapIndicesRight+1,:,1) = floor((stimParams.test.contrast * ramp * ones(1,3) * ...						diag(stimParams.test.colorDir./max(abs(stimParams.test.colorDir))) + ...						0.5) * display.maxGunVal);	cmap(cmapIndicesLeft+1,:,1) = floor((stimParams.stnd.contrast * ramp * ones(1,3) * ...						diag(stimParams.stnd.colorDir./max(abs(stimParams.stnd.colorDir))) + ...						0.5) * display.maxGunVal);end% make last cmap blankcmap(:,:,numCmaps) = floor(ones(display.numColors,3) * 0.5 * display.maxGunVal);cmap = insertReservedCols(display,cmap);% convert 10-bit cmaps to 8-bit cmaps and corresponding gamma tablesif display.cmapDepth == 10	[cmap, gamma] = tenBit2eightBit(display, cmap);end% Create the sequence% the last cMap (# numCmaps) is blank, allowing us to draw invisibly.stimFrames = round(display.frameRate * stimParams.duration);seq = [-numCmaps 1 -1*ones(1,stimFrames) -numCmaps 2];% Compute the images (if needed)% only compute images if they don't exist yet (we aren't manipulating anything that% requires recomputing the images, only the colormaps need to be recomputed).if isempty(data)	% Generate images for both positions	radiusPix = 2*floor(angle2pix(display, stimParams.size/2)/2)+1;	spreadPix =  2*floor(angle2pix(display, stimParams.spread)/2)+1;	rightImg = zeros(radiusPix*2+1, radiusPix*2+1, 2);	leftImg = zeros(radiusPix*2+1, radiusPix*2+1, 2);		[x,y] = meshgrid(-radiusPix:radiusPix,-radiusPix:radiusPix);	% compute gratings	rightImg(:,:,1) = exp(-((x/spreadPix).^2) - ((y/spreadPix).^2)) ...				.* sin(x*.5*stimParams.stnd.cycles/radiusPix*2*pi);	leftImg(:,:,1) = exp(-((x/spreadPix).^2) - ((y/spreadPix).^2)) ...				.* sin(x*.5*stimParams.test.cycles/radiusPix*2*pi);	% scale to the appropriate cmap range	scale = round((cmapIndicesLeft(length(cmapIndicesLeft)) - cmapIndicesLeft(1))/2);	leftImg(:,:,1) = scale * leftImg(:,:,1) + scale + cmapIndicesLeft(1);	scale = round((cmapIndicesRight(length(cmapIndicesRight)) - cmapIndicesRight(1))/2);	rightImg(:,:,1) = scale * rightImg(:,:,1) + scale + cmapIndicesRight(1);		blankImg = ones(radiusPix*2+1, radiusPix*2+1) * backIndex;	rightImg(:,:,2) = blankImg;	leftImg(:,:,2) = blankImg;		testImg = makeNAFCStim(display, leftImg, rightImg, ...				angle2pix(display,stimParams.eccentricity), backIndex);	clear('leftImg');	clear('rightImg');		% insert a fixation point	if isfield(stimParams, 'fixSize')		fixParams.size = stimParams.fixSize;	end	testImg = insertFixation(display, testImg, fixParams);	% Create stimulus by combining the colormaps and image (use 10-bit code, if available)	if display.cmapDepth == 10		data = createStimulusStruct(testImg, cmap, seq, gamma);	else		data = createStimulusStruct(testImg, cmap, seq);	end	clear('testImg');	% add the image pointers	data = createImagePointers(display, data);	else	% the stimulus exists in data, so we just need to update the cmaps and seq	data.cmap = cmap;	if exist('gamma', 'var')		data.gamma = gamma;	end	data.seq = seq;endclear('cmap');clear('seq');% build the trialtrial = addTrialEvent(display,[],'stimulusEvent', 'stimulus', data);%trial = addTrialEvent(display,trial,'responseEvent', ...%					'responseSet', '13', 'answerType', '1toN');%trial = addTrialEvent(display,trial,'feedbackEvent', 'duration', .3, ...%			'feedbackVerticalLocation', 0, 'noResponseText', 'timed out!', ...%			'noResponseColor', 1);