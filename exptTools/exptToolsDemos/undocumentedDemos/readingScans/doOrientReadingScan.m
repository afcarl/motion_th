% doReadingScan% % AUTHOR:  dougherty% DATE:    98/12/14% PURPOSE:% % clear all;runPriority = 0;	% 0 for debugging and setting up, 7 for scanningexperimentNum = 0;% 0 = practice% 1 = single word (A)% 2 = single word (B)invertImgFlag = 0;chdir([machineName,':Users:bob:reading']);addpath([machineName,':Users:bob:reading']);%%% Get parameters %%%[stim, scan, display] = initOrientReadingParams(experimentNum);% the following will produce jpeg images of the stimuli%stim.saveImageDir = 'stimImages';%%% Open the screen %%%display = openScreen(display);%%% Create stimuli %%%% Create colormapsdisp('Creating colormaps and images...');minCmapVal = max([display.reservedColor(:).fbVal])+1;maxCmapVal = display.numColors-1;midCmapVal = ceil((maxCmapVal-minCmapVal+1)/2 + minCmapVal);cmapIndex = minCmapVal:maxCmapVal;backColorIndex = minCmapVal;textColorIndex = minCmapVal+1;lowColorIndex = minCmapVal+2;highColorIndex = minCmapVal+3;numCmaps = 2;cmap = zeros(display.numColors,3,numCmaps);backColor = floor((stim.backRGB.scale * ones(1,3) * ...                    diag(stim.backRGB.dir./max(abs(stim.backRGB.dir)))) * display.maxGunVal);% make first cmap blankcmap(:,:,1) = repmat(backColor, display.numColors,1);% fill second cmap with background first...cmap(:,:,2) = cmap(:,:,1);% then poke in the stimulus colorscmap(backColorIndex+1,:,2) = backColor;cmap(textColorIndex+1,:,2) = round(display.maxGunVal/2 + (stim.stimRGB.scale * ones(1,3) * ...                    diag(stim.stimRGB.dir./max(abs(stim.stimRGB.dir)))) * display.maxGunVal);cmap(lowColorIndex+1,:,2) = round(display.maxGunVal/2 + (stim.noiseLoRGB.scale * ones(1,3) * ...                  diag(stim.noiseLoRGB.dir./max(abs(stim.noiseLoRGB.dir)))) * display.maxGunVal);cmap(highColorIndex+1,:,2) = round(display.maxGunVal/2 + (stim.noiseHiRGB.scale * ones(1,3) * ...                  diag(stim.noiseHiRGB.dir./max(abs(stim.noiseHiRGB.dir)))) * display.maxGunVal);cmap = insertReservedCols(display,cmap);SCREEN(display.windowPtr,'SetClut',cmap(:,:,2));%img = ones([stim.imagePix, 2])*midCmapVal;blankImg = ones([stim.imagePix, 1])*backColorIndex;blankImg = insertFixation(display, blankImg, stim.fix);% Create the sequence% the first cmap is blank, allowing us to draw invisibly.% the second image is blank, so it will erase the first.seq = [-1 1 -2*ones(1,stim.frames) -1 2];feedback2use = standardFeedback(display, scan.feedbackStrings);numType1Items = length(stim.text.strings);disp('Creating type 1 trials...');imWide = size(blankImg,2);imHigh = size(blankImg,1);img = zeros(imHigh, imWide, 2);% we'll keep track of the mean text size so that we can match the size% size of the orientation stimuli.meanTextWide = 0;meanTextHigh = 0;for trialNum=1:numType1Items    % 1-bit random noise	noiseImg = round(rand(imHigh, imWide)*(highColorIndex-lowColorIndex))+lowColorIndex;	    % Draw text into a matrix (background will be 0, text will be 255)	textImg = DrawTextLine2Bitmap(stim.text.strings{trialNum}, ...						stim.text.size, stim.text.font);	% set the text color properly (change 255 into textColorIndex)	textImg = textImg/255 * textColorIndex;	if invertImgFlag		textImg = flipud(textImg);	end    % position text as an offset from the center	textWide = size(textImg,2);	textHigh = size(textImg,1);	if (textWide > imWide)		disp('WARNING! Text image wants to be wider than the alotted image width!');		textWide = imWide;	end	if (textHigh > imHigh)		disp('WARNING! Text image wants to be higher than the alotted image height!');		textHigh = imHigh;	end			meanTextWide = meanTextWide + textWide/numType1Items;	meanTextHigh = meanTextHigh + textHigh/numType1Items;    x = round(imWide/2-textWide/2) + stim.text.positionPix(2) + 1;    y = round(imHigh/2-textHigh/2) + stim.text.positionPix(1) + 1;	img(:,:,1) = noiseImg;	img(:,:,2) = blankImg;	% combine text and noise	% extract a sub-image the same dimentions as the text image	tempImg = img(y:y+textHigh-1, x:x+textWide-1, 1);	% find the non-zero values in the text image	nz = find(textImg(1:textHigh, 1:textWide));	% copy only the non-zero values	tempImg(nz) = textImg(nz);	% put the modified sub-image back into the full image    img(y:y+textHigh-1, x:x+textWide-1, 1) = tempImg;		%%% Create trials %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    %																	%																	%    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		stimulus = createStimulusStruct(img, cmap, seq);    stimulus = createImagePointers(display, stimulus);    if str2num(stim.text.types{trialNum}) == 1        responseSet = '12';    else        responseSet = '21';    end    trials{trialNum} = addTrialEvent(display,[],'stimulusEvent', 'stimulus',stimulus);    trials{trialNum} = addTrialEvent(display,trials{trialNum},'responseEvent',...    				'duration', scan.responseDuration, 'answerType', 'binary', ...    				'responseSet', responseSet);    trials{trialNum} = addTrialEvent(display,trials{trialNum},'feedbackEvent',feedback2use);	end% Create type 2 trialsnumType2Items = numType1Items;linesImgWide = round(meanTextWide*.8);linesImgHigh = round(meanTextHigh*.7);for trialNum=numType1Items+1:numType1Items+numType2Items    % 1-bit random noise	noiseImg = round(rand(imHigh, imWide)*(highColorIndex-lowColorIndex))+lowColorIndex;	tilt = round(rand);	if tilt == 0		orient = randn*stim.lines.orientStdev - stim.lines.orientMean;	else		orient = randn*stim.lines.orientStdev + stim.lines.orientMean;	end		    % Draw lines	linesImg = DrawLines(orient, stim.lines.thickness, stim.lines.spacing, ...						linesImgWide, linesImgHigh, textColorIndex);	if invertImgFlag		linesImg = flipud(linesImg);	end    % position lines as an offset from the center    x = round(imWide/2-linesImgWide/2) + stim.text.positionPix(2) + 1;    y = round(imHigh/2-linesImgHigh/2) + stim.text.positionPix(1) + 1;	img(:,:,1) = noiseImg;	img(:,:,2) = blankImg;	% combine lines and noise	tempImg = img(y:y+linesImgHigh-1, x:x+linesImgWide-1, 1);	nz = find(linesImg(1:linesImgHigh, 1:linesImgWide));	tempImg(nz) = linesImg(nz);    img(y:y+linesImgHigh-1, x:x+linesImgWide-1, 1) = tempImg;		stimulus = createStimulusStruct(img, cmap, seq);    stimulus = createImagePointers(display, stimulus);    if orient < 0        responseSet = '21';    else        responseSet = '12';    end    trials{trialNum} = addTrialEvent(display,[],'stimulusEvent', 'stimulus',stimulus);    trials{trialNum} = addTrialEvent(display,trials{trialNum},'responseEvent',...    				'duration', scan.responseDuration, 'answerType', 'binary', ...    				'responseSet', responseSet);    trials{trialNum} = addTrialEvent(display,trials{trialNum},'feedbackEvent',feedback2use);				end% Create scan structuredisp('Creating scan structure...');doScanStruct.trials = trials;doScanStruct.trialDuration = scan.trialDuration;doScanStruct.prescanDuration = scan.prescanDuration;doScanStruct.prescanStimulus = stimulus;	% one stim from type 2 trialsdoScanStruct.startSecs = scan.startSecs;doScanStruct.startScan = scan.startScan;% this confusing bit of code does the right thing- it produces% a shuffled trial sequence that presents some type one trials then% some type two trials for each cycle.  It samples without replacement% from all the type1 and type2 trials first, then does so again if % needed to flesh out the scan (ie. if it needs 50 type 1 trials an there% are only 40, it will do the 40 randomly and the last 10 will be repeats.)trialSeq{1} = [];trialSeq{2} = [];for i=1:ceil(scan.numTrialsPerEpoch/numType1Items*scan.ncycles)    trialSeq{1} = [trialSeq{1} shuffle([1:numType1Items])];endfor i=1:ceil(scan.numTrialsPerEpoch/numType2Items*scan.ncycles)    trialSeq{2} = [trialSeq{2} shuffle([numType1Items+1:numType1Items+numType2Items])];enddoScanStruct.trialSequence = [];for i=1:scan.ncycles    doScanStruct.trialSequence = [doScanStruct.trialSequence ...         trialSeq{1}((i-1)*scan.numTrialsPerEpoch+1:i*scan.numTrialsPerEpoch) ...        trialSeq{2}((i-1)*scan.numTrialsPerEpoch+1:i*scan.numTrialsPerEpoch)];end        doScanStruct.dispString = scan.dispString;% Start the scan%disp('Ready to start scan.');response = doScan(display,doScanStruct,runPriority,1);disp(['Stimulus time should have been ' num2str(scan.scanDuration+scan.prescanDuration) '.']);% write out behavioural data trialMask{1} = find(doScanStruct.trialSequence <= numType1Items);trialMask{2} = find(doScanStruct.trialSequence > numType1Items);fp = fopen('log', 'at');fprintf(fp, '****\n%s\n', datestr(now,0));for i=1:2	numMissed(i) = sum(isnan(response(trialMask{i})));	validResp = response(trialMask{i});	validResp = validResp(find(~isnan(validResp)));	pc(i) = sum(validResp)/length(validResp);	perf = ['proportion correct = ' num2str(pc(i)) ' ('num2str(numMissed(i)) ' missed trials)'];	disp(perf);	fprintf(fp, 'type %d trials: %s\n', i, perf);end% write out the order of the text itemsfor i=trialSeq{1}	fprintf(fp, '%s\t%d\n', stim.text.strings{i}, response(trialMask{1}(i)));endfclose(fp);% Close the one on-screen and many off-screen windows%SCREEN('CloseAll');